# üìà FINAL STOCK TREND APP WITH FIXES
import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
import os
import json
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score
from xgboost import XGBClassifier
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, SimpleRNN
from tensorflow.keras.callbacks import EarlyStopping

# ------------------------------ DATABASE ------------------------------
USER_DB = {"service_providers": {}, "remote_users": {}}
USER_INFO = {"remote_users": {}, "service_providers": {}}
WATCHLIST_DB = {}

def save_user_db():
    with open("user_db.json", "w") as f:
        json.dump(USER_DB, f)
    with open("user_info.json", "w") as f:
        json.dump(USER_INFO, f)
    with open("watchlist_db.json", "w") as f:
        json.dump(WATCHLIST_DB, f)

def load_user_db():
    global USER_DB, USER_INFO, WATCHLIST_DB
    if os.path.exists("user_db.json"):
        with open("user_db.json", "r") as f:
            USER_DB = json.load(f)
    if os.path.exists("user_info.json"):
        with open("user_info.json", "r") as f:
            USER_INFO = json.load(f)
    if os.path.exists("watchlist_db.json"):
        with open("watchlist_db.json", "r") as f:
            WATCHLIST_DB = json.load(f)

load_user_db()

# ------------------------------ STREAMLIT CONFIG ------------------------------
st.set_page_config(page_title="üìà Stock Trend Predictor", layout="wide")
st.markdown("""
    <style>
        .main { background-color: #e5f4ea; }
        .stButton>button { background-color: #0e4429; color: white; border-radius: 8px; }
        .stTextInput>div>input { background-color: #f1fff7; }
        h1, h2, h3, .stMarkdown { color: #114e3b; }
    </style>
""", unsafe_allow_html=True)

# ------------------------------ AUTH ------------------------------
def login_user(role):
    st.subheader(f"üîê {role.title().replace('_', ' ')} Login")
    username = st.text_input("Username", key=f"{role}_username")
    password = st.text_input("Password", type="password", key=f"{role}_password")
    if st.button("Login", key=f"{role}_login"):
        if username in USER_DB[role] and USER_DB[role][username] == password:
            st.session_state.logged_in = True
            st.session_state.user_role = role
            st.session_state.username = username
        else:
            st.error("Invalid username or password")

def register_user():
    st.subheader("üìù Register (Remote User)")
    new_user = st.text_input("Choose Username")
    new_pass = st.text_input("Choose Password", type="password")
    email = st.text_input("Email")
    mobile = st.text_input("Mobile Number")
    if st.button("Register"):
        if new_user in USER_DB['remote_users']:
            st.warning("Username already exists")
        else:
            USER_DB['remote_users'][new_user] = new_pass
            USER_INFO['remote_users'][new_user] = {"email": email, "mobile": mobile}
            WATCHLIST_DB[new_user] = []
            save_user_db()
            st.success("Registration successful. You can now login.")

def register_service_provider():
    st.subheader("üìù Register (Service Provider)")
    new_user = st.text_input("Choose SP Username")
    new_pass = st.text_input("Choose SP Password", type="password")
    email = st.text_input("SP Email")
    mobile = st.text_input("SP Mobile")
    if st.button("Register SP"):
        if new_user in USER_DB['service_providers']:
            st.warning("Service Provider already exists")
        else:
            USER_DB['service_providers'][new_user] = new_pass
            USER_INFO['service_providers'][new_user] = {"email": email, "mobile": mobile}
            save_user_db()
            st.success("Service Provider registered successfully")

# ------------------------------ PREDICTION HELPERS ------------------------------
@st.cache_data
def load_data(ticker):
    df = yf.download(ticker, start="2013-01-01")  # Removed fixed end date to always get latest
    df.reset_index(inplace=True)
    return df

def add_indicators(df):
    df['SMA'] = df['Close'].rolling(window=14).mean()
    df['EMA'] = df['Close'].ewm(span=14).mean()
    delta = df['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(14).mean()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs))
    df['MACD'] = df['Close'].ewm(span=12).mean() - df['Close'].ewm(span=26).mean()
    df['OBV'] = (np.sign(df['Close'].diff()) * df['Volume']).fillna(0).cumsum()
    df['Momentum'] = df['Close'] - df['Close'].shift(10)
    df['StdDev'] = df['Close'].rolling(window=10).std()
    df['ROC'] = df['Close'].pct_change(periods=10)
    df['Williams %R'] = (df['High'].rolling(14).max() - df['Close']) / \
                        (df['High'].rolling(14).max() - df['Low'].rolling(14).min()) * -100
    df.dropna(inplace=True)
    return df

def create_labels(df):
    df['Target'] = np.where(df['Close'].shift(-1) > df['Close'], 1, 0)
    return df

def preprocess(df):
    features = ['SMA', 'EMA', 'RSI', 'MACD', 'OBV', 'Momentum', 'StdDev', 'ROC', 'Williams %R']
    X = df[features]
    y = df['Target']
    scaler = StandardScaler()
    X = scaler.fit_transform(X)
    return train_test_split(X, y, shuffle=False, test_size=0.2), X

def train_ml_models(X_train, y_train):
    rf = RandomForestClassifier()
    svm = SVC(probability=True)
    xgb = XGBClassifier(use_label_encoder=False, eval_metric='logloss')
    rf.fit(X_train, y_train)
    svm.fit(X_train, y_train)
    xgb.fit(X_train, y_train)
    return rf, svm, xgb

def reshape(X):
    return X.reshape((X.shape[0], 1, X.shape[1]))

def build_lstm(input_shape):
    model = Sequential([LSTM(64, input_shape=input_shape), Dense(1, activation='sigmoid')])
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

def train_deep_model(model, X_train, y_train):
    model.fit(X_train, y_train, epochs=10, batch_size=32, verbose=0,
              callbacks=[EarlyStopping(monitor='loss', patience=3)])
    return model

def get_model_prediction(model, X_test, y_test=None, deep=False):
    y_pred = model.predict(X_test)
    if deep: y_pred = y_pred.flatten()
    y_pred_class = (y_pred > 0.5).astype(int)
    acc = accuracy_score(y_test, y_pred_class) if y_test is not None else 0
    return y_pred_class[-1], acc

def get_final_prediction(X_train, X_test, y_train, y_test):
    rf, svm, xgb = train_ml_models(X_train, y_train)
    X_train_rnn, X_test_rnn = reshape(X_train), reshape(X_test)
    lstm = train_deep_model(build_lstm(X_train_rnn.shape[1:]), X_train_rnn, y_train)
    preds = {
        "RF": get_model_prediction(rf, X_test, y_test),
        "SVM": get_model_prediction(svm, X_test, y_test),
        "XGB": get_model_prediction(xgb, X_test, y_test),
        "LSTM": get_model_prediction(lstm, X_test_rnn, y_test, deep=True),
    }
    votes, weights = zip(*preds.values())
    final = int(np.average(votes, weights=weights) >= 0.5)
    return final

def plot_price(df, symbol, prediction):
    df['Date'] = pd.to_datetime(df['Date'])
    last_year = df[df['Date'] >= (df['Date'].max() - pd.Timedelta(days=365))]
    plt.figure(figsize=(14, 6))
    plt.plot(last_year['Date'], last_year['Close'], label='Close Price')
    signal = last_year['Close'].iloc[-1]
    next_day = last_year['Date'].iloc[-1] + pd.Timedelta(days=1)
    color = 'green' if prediction == 1 else 'red'
    marker = '^' if prediction == 1 else 'v'
    label = 'Predicted Up üìà' if prediction == 1 else 'Predicted Down üìâ'
    plt.scatter(next_day, signal, color=color, s=100, label=label, marker=marker)
    plt.title(f"Stock Price Trend for {symbol}")
    plt.xlabel("Date")
    plt.ylabel("Close Price")
    plt.grid(True)
    plt.legend()
    st.pyplot(plt)

# ------------------------------ UI ------------------------------
if 'logged_in' not in st.session_state:
    st.session_state.logged_in = False

st.title("üí∞ Stock Market Trend Prediction using ML & DL")

if not st.session_state.logged_in:
    tab1, tab2, tab3, tab4 = st.tabs(["SP Login", "Remote User Login", "Register User", "Register SP"])
    with tab1: login_user("service_providers")
    with tab2: login_user("remote_users")
    with tab3: register_user()
    with tab4: register_service_provider()
else:
    st.sidebar.success(f"Logged in as {st.session_state.username} ({st.session_state.user_role.replace('_',' ').title()})")
    st.sidebar.button("Logout", on_click=lambda: st.session_state.clear())
    st.markdown(f"### üëã Hello, **{st.session_state.username}**!!")

    if st.session_state.user_role == "service_providers":
        st.subheader("üë• Registered Remote Users")
        df_users = pd.DataFrame.from_dict(USER_INFO.get("remote_users", {}), orient="index").reset_index()
        df_users.columns = ["Username", "Email", "Mobile"]
        st.dataframe(df_users if not df_users.empty else pd.DataFrame([{"Username": "-", "Email": "-", "Mobile": "-"}]))

    st.subheader("‚≠ê Watchlist")
    watchlist = WATCHLIST_DB.get(st.session_state.username, [])
    new_stock = st.text_input("Add stock to watchlist (e.g., INFY.NS)")
    if st.button("Add to Watchlist"):
        if new_stock and new_stock.upper() not in watchlist:
            watchlist.append(new_stock.upper())
            WATCHLIST_DB[st.session_state.username] = watchlist
            save_user_db()
    if watchlist:
        st.write("Your Watchlist:", watchlist)
        uptrend, downtrend = [], []
        for symbol in watchlist:
            try:
                df = load_data(symbol)
                df = add_indicators(df)
                df = create_labels(df)
                (X_train, X_test, y_train, y_test), _ = preprocess(df)
                prediction = get_final_prediction(X_train, X_test, y_train, y_test)
                (uptrend if prediction == 1 else downtrend).append(symbol)
            except:
                st.warning(f"Data unavailable for {symbol}")
        st.success(f"üìà Uptrend: {uptrend}" if uptrend else "üìà No stocks in uptrend")
        st.error(f"üìâ Downtrend: {downtrend}" if downtrend else "üìâ No stocks in downtrend")

    # üîç Search & Predict
    st.subheader("üîç Search and Predict a Stock")
    search_symbol = st.text_input("Enter stock symbol to search (e.g., UPL.NS, TCS.NS)")
    if st.button("Predict Trend") and search_symbol:
        try:
            df = load_data(search_symbol)
            df = add_indicators(df)
            df = create_labels(df)
            (X_train, X_test, y_train, y_test), _ = preprocess(df)
            prediction = get_final_prediction(X_train, X_test, y_train, y_test)
            st.success("üìà Predicted Uptrend" if prediction == 1 else "üìâ Predicted Downtrend")
            plot_price(df, search_symbol.upper(), prediction)
        except Exception as e:
            st.error(f"Error: {e}")
